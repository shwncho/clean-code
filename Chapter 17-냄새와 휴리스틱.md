# 17장 냄새와 휴리스틱

### 나쁜 냄새 목록

- 주석
    - C1: 부적절한 정보
        - 작성자, 최종 수정일, SPR 등과 같은 메타 정보만 주석으로 넣는다.
        - 주석은 코드와 설계에 기술적인 설명을 부연하는 수단이다.
    - C2: 쓸모 없는 주석
        - 쓸모 없어진 주석은 재빨리 삭제하는 편이 가장 좋다.
    - C3: 중복된 주석
        - 코드만으로 충분한데 구구절절 설명하는 주석이 중복된 주석이다.
    - C4: 성의 없는 주석
    - C5: 주석 처리된 코드
        - 주석으로 처리된 코드를 내버려 두지 마라.

- 환경
    - E1: 여러 단계로 빌드해야 한다
    - E2: 여러 단계로 테스트해야 한다
        - 모든 단위 테스트는 한 명령으로 돌려야 한다.

- 함수
    - F1: 너무 많은 인수
        - 함수에서 인수 개수는 작을수록 좋다.
    - F2: 출력 인수
    - F3: 플래그 인수
    - F4: 죽은 함수
        - 아무도 호출하지 않는 함수는 삭제한다.

- 일반
    - G1: 한 소스 파일에 여러 언어를 사용한다
        - 소스 파일 하나에 언어 하나만 사용하는 방식이 가장 좋다.
        - 현실적으로는 여러 언어가 불가피하므로, 각별한 노력을 기울여 소스 파일에서 언어 수와 범위를 최대한 줄이도록 애써야 한다.
    - G2: 당연한 동작을 구현하지 않는다
        - 함수나 클래스는 다른 프로그래머가 당연하게 여길 만한 동작과 기능을 제공해야 한다.
    - G3: 경계를 올바로 처리하지 않는다
    - G4: 안전 절차 무시
        - 실패하는 테스트 케이스를 일단 제껴두고 나중으로 미루는 태도는 신용카드가 공짜 돈이라는 생각만큼 위험하다.
    - G5: 중복
        - 코드에서 중복을 발견할 때마다 추상화할 기회로 간주하라.
        - 중복은 Template Method 패턴이나 Strategy 패턴으로 제거한다.
    - G6: 추상화 수준이 올바르지 못하다
        - 모든 저차원 개념은 파생 클래스에 넣고, 모든 고차원 개념은 기초 클래스에 넣는다.
    - G7: 기초 클래스가 파생 클래스에 의존한다
        - 고차원 기초 클래스 개념은 저차원 파생 클래스 개념으로부터 분리해 독립성을 보장하기 위해서 기초 클래스와 파생 클래스로 나눈다.
        - 그러므로 기초 클래스가 파생 클래스를 사용한다면 뭔가 문제가 있다.
    - G8: 과도한 정보
        - 잘 정의된 모듈은 인터페이스가 아주 작다.
        - 정보를 제한해 결합도를 낮춰라.
    - G9: 죽은 코드
        - 죽은 코드란 실행되지 않는 코드
        - 시스템에서 제거하라.
    - G10: 수직 분리
        - 변수와 함수는 사용되는 위치에 가깝게 정의한다.
        - 비공개 함수는 처음으로 호출한 직후에 정의한다.
    - G11: 일관성 부족
        - 어떤 개념을 특정 방식으로 구현했다면 유사한 개념도 같은 방식으로 구현한다.
    - G12: 잡동사니
    - G13: 인위적 결합
        - 서로 무관한 개념을 인위적으로 결합하지 않는다.
    - G14: 기능 욕심
        - 클래스 메서드는 자기 클래스의 변수와 함수에 관심을 가져야지 다른 클래스의 변수와 함수에 관심을 가져서는 안된다.
    - G15: 선택자 인수
        - 인수를 넘겨 동작을 선택하는 대신 새로운 함수를 만드는 편이 좋다.
    - G16: 모호한 의도
        - 코드를 짤 때는 의도를 최대한 분명히 밝힌다.
    - G17: 잘못 지운 책임
    - G18: 부적절한 static 함수
        - 조금이라도 의심스럽다면 인스턴스 함수로 정의한다.
        - 반드시 static 함수로 정의해야겠다면 재정의할 가능성은 없는지 꼼꼼히 따져본다.
    - G19: 서술적 변수
        - 프로그램 가독성을 높이는 가장 효과적인 방법 중 하나가 계산을 여러 단계로 나누고 중간 값으로 서술적인 변수 이름을 사용하는 방법이다.
    - G20: 이름과 기능이 일치하는 함수
    - G21: 알고리즘을 이해하라
    - G22: 논리적 의존성은 물리적으로 드러내라
    - G23: If/Else 혹은 Switch/Case 문보다 다형성을 사용하라
    - G24: 표준 표기법을 따르라
    - G25: 매직 숫자는 명명된 상수로 교체하라
        - ex) WORK_HOURS_PER_DAY
    - G26: 정확하라
        - 코드에서 뭔가를 결정할 때는 정확히 결정한다.
    - G27: 관례보다 구조를 사용하라
    - G28: 조건을 캡슐화하라
    - G29: 부정 조건은 피하라
    - G30: 함수는 한 가지만 해야 한다
    - G31: 숨겨진 시간적인 결합
    - G32: 일관성을 유지하라
    - G33: 경계 조건을 캡슐화하라
    - G34: 함수는 추상화 수준을 한 단계만 내려가야 한다
    - G35: 설정 정보는 최상위 단계에 둬라
    - G36: 추이적 탐색을 피하라
        - 한 모듈은 주변 모듈을 모를 수록 좋다.
            - A가 B를 사용하고, B가 C를 사용한다 하더라도 A가 C를 알아야 할 필요는 없다는 뜻

- 자바
    - J1: 긴 import 목록을 피하고 와일드카드를 사용하라
    - J2: 상수는 상속하지 않는다
    - J3: 상수 대 Enum

- 이름
    - N1: 서술적인 이름을 사용하라
        - 서술적이 이름을 신중하게 고른다.
    - N2: 적절한 추상화 수준에서 이름을 선택하라
    - N3: 가능하다면 표준 명명법을 사용하라
    - N4: 명확한 이름
        - 함수나 변수의 목적을 명확히 밝히는 이름을 선택한다.
    - N5: 긴 범위는 긴 이름을 사용하라
    - N6: 인코딩을 피하라
    - N7: 이름으로 부수 효과를 설명하라

- 테스트
    - T1: 불충분한 테스트
        - 테스트 케이스는 잠재적으로 깨질 만한 부분을 모두 테스트해야 한다.
    - T2: 커버리지 도구를 사용하라!
    - T3: 사소한 테스트를 건너뛰지 마라
    - T4: 무시한 테스트는 모호함을 뜻한다
    - T5: 경계 조건을 테스트하라
    - T6: 버그 주변은 철저히 테스트하라
    - T7: 실패 패턴을 살펴라
    - T8: 테스트 커버리지 패턴을 살펴라
    - T9: 테스트는 빨라야 한다

- 결론
    - 이 장에서 소개한 휴리스틱과 냄새 목록이 완전하다 말하기는 어렵다.
    - 일군의 규칙만 따른다고 깨끗한 코드가 얻어지지 않는다
    - 전문가 정신과 장인 정신은 가치에서 나온다.
    - 그 가치에 기반한 규율과 절제가 필요하다.